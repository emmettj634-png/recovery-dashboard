

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<div class="header">
<title>Oklahoma Elite Recovery Dashboard</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>


<style>

.chart-box {
  position: relative;
}

.chart-box canvas {
  min-height: 380px !important;
}
@media (max-width: 768px){
  .chart-box{
    display:block !important;
  }
}

/* === Trend arrows === */
.trend-up.light { color: #9BE7A6; }    /* light green */
.trend-up.medium { color: #4CAF50; }  /* medium green */
.trend-up.dark { color: #1B5E20; }    /* dark green */

.trend-down.light { color: #F28B82; }  /* light red */
.trend-down.medium { color: #E53935; } /* medium red */
.trend-down.dark { color: #8E0000; }   /* dark red */

.empty-state{
  text-align:center;
  font-style:italic;
  opacity:0.8;
  padding:20px;
}

:root{
  --bg-core:#8E1B1C;
  --bg-edge:#5A0E0F;
  --card:rgba(255,255,255,.15);
  --text:#FDF9D8;
}

body{
  background-color: #6F1213;
  background:
    radial-gradient(
      circle at top center,
      var(--bg-core) 0%,
      #6F1213 40%,
      var(--bg-edge) 100%
    );
  background-attachment: fixed; /* ‚úÖ THIS LINE */
  color:var(--text);
  font-family:Arial, sans-serif;
  position: relative;
}

/* =====================
   DESKTOP STRONGER GRADIENT
====================== */
@media (min-width: 769px){
  body{
    background:
      radial-gradient(
        circle at 50% 18%,
        #7F1618 0%,
        #7A1416 35%,
        #4A0C0D 100%
      );
    background-attachment: fixed;
  }
}


body::before{
  content:"";
  position: fixed;
  inset: 0;
  background-image: url("data:image/svg+xml;utf8,\
<svg xmlns='http://www.w3.org/2000/svg' width='120' height='120'>\
<filter id='n'><feTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='4'/></filter>\
<rect width='120' height='120' filter='url(%23n)' opacity='0.03'/></svg>");
  pointer-events:none;
  z-index:-1;
}



.container{
  max-width:1400px;
  margin:auto;
  padding:20px;
}
h1{text-align:center;font-size:3.9rem;}
.controls{
  display:flex;
  gap:12px;
  flex-wrap:wrap;
  justify-content:center;
  margin-bottom:25px;
}
select,button{
  padding:10px;
  border-radius:6px;
  border:none;
  font-weight:bold;
}
button{cursor:pointer;}
.hidden{
  display:none !important;
}


.stats-grid,.module-grid{
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(220px,1fr));
  gap:15px;
}
.stat-card,.module-card{
  background:var(--card);
  padding:15px;
  border-radius:8px;
}
.module-card h3{
  border-bottom:1px solid rgba(253,249,216,.4);
  margin-bottom:6px;
}
.module-card ul{list-style:none;padding-left:0;}
.module-card li{font-size:.9rem;}

.chart-box{
  height:380px;
  margin-top:25px;
  display:flex;
  justify-content:center;
  align-items:center;
}
.chart-box canvas{max-width:900px;}

.team-position{margin-top:40px;}
.team-position h2{text-align:center;}

.leaderboard-grid{
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(300px,1fr));
  gap:25px;
  justify-content:center;
  max-width:1200px;
  margin:0 auto;
}
.leaderboard{
  background:var(--card);
  padding:15px;
  border-radius:8px;
}
.leaderboard h3{text-align:center;}
.leaderboard li{color:#FDF9D8;}

/* =====================
   FROSTED GLASS CARDS
====================== */

.stat-card,
.module-card,
.leaderboard{
  background: rgba(255,255,255,0.22);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  border: 1px solid rgba(255,255,255,0.18);
  box-shadow:
    0 10px 25px rgba(0,0,0,0.25),
    inset 0 1px 0 rgba(255,255,255,0.15);
  border-radius: 10px;
}

@media (max-width: 768px){
  body{
    background: #6F1213 !important; /* force non-white */
    background-attachment: scroll;
  }
}

/* =========================
   TEAM RANK MOBILE STACK
========================= */

@media (max-width: 900px) {
  #teamRankSection .leaderboard {
    grid-template-columns: 1fr !important;
  }
}

</style>
</head>

<body>
<div class="container">

<div class="header">
  
<h1>Oklahoma Elite Recovery</h1>
  
<div class="controls">
  <select id="positionFilter">
    <option value="">Select Position</option>
    <option>QB</option><option>RB</option><option>WR</option><option>TE</option>
    <option>OL</option><option>DT</option><option>DE</option>
    <option>CB</option><option>S</option><option>LB</option><option>Specialists</option>
  </select>

  <select id="playerFilter">
    <option value="">Select Player</option>
  </select>

  <select id="dateFilter">
    <option value="">Select Date</option>
  </select>

  <button id="toggleView">Team View</button>
</div>

<!-- ================= PLAYER VIEW ================= -->
<div id="playerView">

<h2 id="playerDetailsTitle">Player Details</h2>
<div id="playerDetailsEmpty" class="empty-state">
  Select a player to view details
</div>
<div id="playerStatsGrid" class="stats-grid hidden">
<div class="stat-card">

  <span id="recoveryDaysLabel">
    Recovery Days (This Week)
  </span>

  <span
    id="weekToggleLink"
    style="
      font-size:.60rem;
      font-weight:bold;
      opacity:.85;
      cursor:pointer;
      margin-left:6px;
    ">
    show last week
  </span>

  <br>

  <strong id="playerRecoveryDays">
    -
  </strong>

</div>


  <div class="stat-card">Last Recovery Date<br><strong id="playerLastDate">-</strong></div>
  <div class="stat-card">Most Popular Module<br><strong id="playerMostModule">-</strong></div>
  <div class="stat-card">

  <span id="rankLabel">
    Rank in Position (This Week)
  </span><br>

  <strong id="playerRank">-</strong>

</div>
</div>
  
<h2 id="positionModuleTitle">Module Participation</h2>
<div id="selectedDateLabel" style="text-align:center;font-weight:bold;"></div>
<div id="moduleGrid" class="module-grid"></div>

<h2>Performance Trend</h2>
<div class="chart-box">
  <canvas id="playerPerformanceChart"></canvas>
</div>

<h2 id="playerModuleTitle">Cumulative Module Usage</h2>
<div class="chart-box" id="playerModuleContainer">
  <div class="empty-state">Select a player to view cumulative module usage</div>
  <canvas id="playerModuleChart" style="display:none;"></canvas>
</div>

  <h2>Average Monthly Participation by Position (%)</h2>
<div class="controls">
  <select id="monthFilter"></select>
  <select id="monthWeekFilter"></select>
</div>
<div class="chart-box">
  <canvas id="monthlyAvgChart"></canvas>
</div>

<h2>Module Usage by Position (%)</h2>

<div class="controls" style="justify-content:center;">
  <select id="moduleBreakdownSelect">
    <option value="">Select Module</option>
  </select>
</div>

<div class="chart-box">
  <canvas id="moduleBreakdownChart"></canvas>
</div>


<h2>Total Team Module Usage (All Dates)</h2>
<div class="chart-box"><canvas id="moduleChart"></canvas></div>

</div>

<!-- ================= TEAM VIEW ================= -->
<div id="teamView" class="hidden">

<div style="text-align:center; margin:20px 0;">
  <button id="teamRankToggleBtn">Team Ranks</button>
</div>

<div id="teamModuleSection">
  <h2 style="text-align:center;">
    Team Module Participation (Selected Date)
  </h2>
  <div id="teamModuleGrid"></div>
</div>

<div id="teamRankSection" class="hidden"></div>

<hr style="margin:40px 0;opacity:.4;">



<div id="weeklyLeaderboardSection" class="hidden">

  <h2 style="text-align:center;">
    Weekly Participation Leaderboard
  </h2>

  <div style="text-align:center;margin-bottom:15px;">
    <select id="weekFilter"></select>
  </div>

  <div id="leaderboardContainer"
       class="leaderboard-grid"></div>

</div>


</div>

</div>

<script>
document.addEventListener("DOMContentLoaded",()=>{
let showingLastWeek = false;

const weekToggleLink =
  document.getElementById("weekToggleLink");

const recoveryDaysLabel =
  document.getElementById("recoveryDaysLabel");

weekToggleLink.onclick = () => {

  showingLastWeek = !showingLastWeek;

  showPlayer(); // re-render stats
};
function inputDatesAllowDecline(prevInputs, currentInputs) {
  // Current week must exist visually
  if (currentInputs === 0) return false;

  // Same input counts allowed (down to 2 ‚Üí 2)
  if (prevInputs === currentInputs && prevInputs >= 2) {
    return true;
  }

  // -1 pattern allowed from 7 down to 3
  if (
    prevInputs >= 3 &&
    prevInputs <= 7 &&
    prevInputs - currentInputs === 1
  ) {
    return true;
  }

  return false;
}

function teamInputDatesInRange(start, end) {
  const dates = new Set();

  playerData.forEach(p => {
    p.sessions.forEach(s => {
      const d = new Date(s.date);
      if (d >= start && d <= end) {
        dates.add(s.date);
      }
    });
  });

  return dates.size;
}

function validTeamInputDatesInRange(start, end){

  const dateCounts = {};

  playerData.forEach(p=>{
    p.sessions.forEach(s=>{

      const d = new Date(s.date);

      if(d >= start && d <= end){

        dateCounts[s.date] ??= new Set();
        dateCounts[s.date].add(p.name);

      }

    });
  });

  // only count dates with ‚â•10 unique participants
  return Object.values(dateCounts)
    .filter(set => set.size >= 10)
    .length;
}

  
function trendIndicator(
  current,
  previous,
  currentInputs,
  previousInputs
){

  // No data either week
  if (previous === 0 && current === 0) return "";

  /* =====================
     SPECIAL CASES
  ====================== */

  // 0 ‚Üí 1 = light green improvement
  if(previous === 0 && current === 1){
    return `<span class="trend-up light"> ‚ñ≤</span>`;
  }

  // 0 ‚Üí 2 = small positive momentum
  if(previous === 0 && current === 2){
    return `<span class="trend-up light"> ‚ñ≤</span>`;
  }

  // 2 ‚Üí 3 = light green improvement
  if(previous === 2 && current === 3){
    return `<span class="trend-up light"> ‚ñ≤</span>`;
  }

  // 2 ‚Üí 0 = explicit decline exception (UNCHANGED)
  if(previous === 2 && current === 0){
    return `<span class="trend-down medium"> ‚ñº</span>`;
  }

/* =====================
   DECLINE LOGIC (RED)
====================== */

// üî¥ Dark red: 3 ‚Üí 0 recovery days
if (previous === 3 && current === 0) {
  return `<span class="trend-down dark"> ‚ñº</span>`;
}

// üî¥ Medium red: 2 ‚Üí 0 recovery days
if (previous === 2 && current === 0) {
  return `<span class="trend-down medium"> ‚ñº</span>`;
}

// ‚ùå Block low-level single-step noise
if (
  (previous === 3 && current === 2) ||
  (previous === 2 && current === 1) ||
  (previous === 1 && current === 0)
) {
  return "";
}

// Standard decline (after input-date eligibility)
if (
  current < previous &&
  inputDatesAllowDecline(previousInputs, currentInputs)
) {
  const percentDrop = (previous - current) / previous;

  if (percentDrop >= 0.2857) {
    return `<span class="trend-down light"> ‚ñº</span>`;
  }
}



  /* =====================
     IMPROVEMENT LOGIC (GREEN)
  ====================== */

  if(current > 2 && current > previous){
    const change = previous === 0 ? 1 : (current - previous) / previous;

    // Cutoff +16%
    if(change >= 0.16){
      let level = "light";
      if(change >= 0.75) level = "dark";
      else if(change >= 0.5) level = "medium";

      return `<span class="trend-up ${level}"> ‚ñ≤</span>`;
    }
  }

  return "";
}

function fmtDate(d){
  const x = new Date(d);
  return `${String(x.getMonth()+1).padStart(2,"0")}-${String(x.getDate()).padStart(2,"0")}-${x.getFullYear()}`;
}
const monthKey = d => {
  const x = new Date(d);
  return `${x.getFullYear()}-${String(x.getMonth()+1).padStart(2,"0")}`;
};
const weekRange = d => {
  const x = new Date(d);
  const start = new Date(x);
  start.setDate(x.getDate() - x.getDay()); // Sunday start
  const end = new Date(start);
  end.setDate(start.getDate() + 6);

  const fmt = y =>
    `${String(y.getMonth()+1).padStart(2,"0")}-${String(y.getDate()).padStart(2,"0")}-${y.getFullYear()}`;

  return {
    start,
    end,
    label: `${fmt(start)}-${fmt(end)}`
  };
};
const weekOfMonth = d => {
  const x = new Date(d);
  const first = new Date(x.getFullYear(), x.getMonth(), 1);
  return Math.ceil((x.getDate() + first.getDay()) / 7);
};

/* ================= CONSTANTS ================= */
const cream="#FDF9D8";
const modules=["Cryo","Red Light","Cold Tub","Hot Tub","Massage Chair","Manual Massages","Cocoon"];
const positions=["QB","RB","WR","TE","OL","DT","DE","CB","S","LB","Specialists"];
const positionNotes = {
  QB: "Lackluster start to the semester",
  RB: "Newcomers have killed it, but vets need to improve",
  WR: "Very top-heavy group; daily improvement",
  TE: "Rocky, Hayden, and Locke take care like no other",
  OL: "Complete transformation since last fall. Elite.",
  DT: "Plenty of guys need to step up in this group",
  DE: "Getting guys like Wein to put in a daily deposit",
  CB: "Solid overall. Impressed with Newcombe so far",
  S: "Group knows how to be intentional and disciplined",
  LB: "Kip is doing more than he ever has - great group",
  Specialists: "Have and continue to be solid"
};
const positionColors = {
  QB: "#FDF9D8",
  RB: "#E53935",
  WR: "#C62828",
  TE: "#AD1457",
  OL: "#8E0000",
  DT: "#6F1213",
  DE: "#B71C1C",
  CB: "#D32F2F",
  S: "#9A1F21",
  LB: "#7A1416",
  Specialists: "#4A0C0D"
};
const monthFilter = document.getElementById("monthFilter");
const monthWeekFilter = document.getElementById("monthWeekFilter");
const moduleBreakdownSelect =
  document.getElementById("moduleBreakdownSelect");



/* ================= FULL ROSTER ================= */
const roster = [
  {name:"Ace Hodges",position:"OL"},
  {name:"Alex Shieldnight",position:"DE"},
  {name:"Andy Bass",position:"RB"},
  {name:"Barrett Travis",position:"LB"},
  {name:"Beau Jandreau",position:"LB"},
  {name:"Ben Anderson",position:"Specialists"},
  {name:"Ben McCreary",position:"RB"},
  {name:"Bergin Kysar",position:"DE"},
  {name:"Bishop Thomas",position:"DT"},
  {name:"Bowe Bentley",position:"QB"},
  {name:"Brian Harris",position:"DT"},
  {name:"CJ Nickson",position:"DE"},
  {name:"Caleb Nitta",position:"OL"},
  {name:"Casen Calmus",position:"S"},
  {name:"Cole Sullivan",position:"LB"},
  {name:"Courtland Guillory",position:"CB"},
  {name:"Dakoda Fields",position:"CB"},
  {name:"Dane Bathurst",position:"LB"},
  {name:"Daniel Akinkunmi",position:"OL"},
  {name:"Daniel Odom",position:"WR"},
  {name:"Danny Okoye",position:"DE"},
  {name:"Darius Afalava",position:"OL"},
  {name:"David Rowaiye",position:"DT"},
  {name:"David Stone",position:"DT"},
  {name:"DeZephen Walker",position:"RB"},
  {name:"Deacon Schmitt",position:"OL"},
  {name:"Derrick Johnson",position:"CB"},
  {name:"E'Marion Harris",position:"OL"},
  {name:"Eddy Pierre-Louis",position:"OL"},
  {name:"Eli Bowen",position:"CB"},
  {name:"Eli Merck",position:"WR"},
  {name:"Elijah Thomas",position:"WR"},
  {name:"Emmanuel Choice",position:"WR"},
  {name:"Fred Hinton",position:"OL"},
  {name:"Gabe Sawchuk",position:"RB"},
  {name:"Grayson Miller",position:"Specialists"},
  {name:"Gunnar Allen",position:"OL"},
  {name:"Hayden Hansen",position:"TE"},
  {name:"Heath Ozaeta",position:"OL"},
  {name:"Isaiah Sategna",position:"WR"},
  {name:"Ivan Carreon",position:"WR"},
  {name:"Jack Van Dorselaer",position:"TE"},
  {name:"Jacob Curry",position:"LB"},
  {name:"Jacob Henry",position:"DT"},
  {name:"Jacob Jordan",position:"WR"},
  {name:"Jacob Ulrich",position:"Specialists"},
  {name:"Jacobe Johnson",position:"CB"},
  {name:"Jahsiear Rogers",position:"WR"},
  {name:"Jake Kreul",position:"DE"},
  {name:"Jake Maikkula",position:"OL"},
  {name:"James Carrington",position:"DT"},
  {name:"James Nesta",position:"LB"},
  {name:"Jayden Jackson",position:"DT"},
  {name:"Jayden Petit",position:"WR"},
  {name:"Jer'Michael Carter",position:"WR"},
  {name:"Jeremiah Newcombe",position:"CB"},
  {name:"Jett Niu",position:"QB"},
  {name:"John Locke",position:"TE"},
  {name:"John Mateer",position:"QB"},
  {name:"Jonathan Hatton",position:"RB"},
  {name:"Kade McIntyre",position:"TE"},
  {name:"Kenneth Wermy",position:"OL"},
  {name:"Kenny Ozowalu",position:"DE"},
  {name:"Kip Lewis",position:"LB"},
  {name:"Kristan Moore",position:"LB"},
  {name:"Liam Evans",position:"Specialists"},
  {name:"Lloyd Avant",position:"RB"},
  {name:"Mackenzie Alleyne",position:"WR"},
  {name:"Marcus James",position:"LB"},
  {name:"Markel Ford",position:"S"},
  {name:"Matthew Nelson",position:"DE"},
  {name:"Michael Boganowski",position:"S"},
  {name:"Michael Fasusi",position:"OL"},
  {name:"Nigel Smith",position:"DT"},
  {name:"Niko Jandreau",position:"S"},
  {name:"Noah Best",position:"OL"},
  {name:"Omarion Robinson",position:"S"},
  {name:"Owen Hollenbeck",position:"OL"},
  {name:"PJ Adebawore",position:"DE"},
  {name:"Parker Livingstone",position:"WR"},
  {name:"Peyton Bowen",position:"S"},
  {name:"Peyton Joseph",position:"OL"},
  {name:"Preston Mickens",position:"CB"},
  {name:"Preston Tarpley",position:"Specialists"},
  {name:"Prince Ijioma",position:"CB"},
  {name:"Reed DeQuasie",position:"S"},
  {name:"Reggie Powers",position:"S"},
  {name:"Rocky Beers",position:"TE"},
  {name:"Ryan Fodje",position:"OL"},
  {name:"Ryder Mix",position:"TE"},
  {name:"Sean Hutton",position:"OL"},
  {name:"Seth Freeman",position:"Specialists"},
  {name:"Tate Sandell",position:"Specialists"},
  {name:"Taylor Heim",position:"LB"},
  {name:"Taylor Wein",position:"DE"},
  {name:"Tory Blaylock",position:"RB"},
  {name:"Trace Rudd",position:"Specialists"},
  {name:"Trell Harris",position:"WR"},
  {name:"Trent Wilson",position:"DT"},
  {name:"Trey Brown",position:"WR"},
  {name:"Trynae Washington",position:"TE"},
  {name:"Trystan Haynes",position:"CB"},
  {name:"Tyler Ruxer",position:"TE"},
  {name:"Whitt Newbauer",position:"QB"},
  {name:"Wyatt Gilmore",position:"DE"},
  {name:"Xavier Robinson",position:"RB"},
  {name:"eLGee Webster",position:"LB"}
];

let playerData = roster.map(p => ({
  ...p,
  sessions: [],
  hawkin: []   // ‚Üê NEW
}));

const uniqueDates=p=>[...new Set(p.sessions.map(s=>s.date))];

/* ================= CSV LOAD ================= */
async function loadCSV(){
  const res = await fetch("eliterecoverykey.csv?v=" + Date.now());
  const text = await res.text();

  playerData.forEach(p => p.sessions = []);

  text.split("\n").slice(1).forEach(r=>{
    if(!r.trim()) return;

    const [n, m, d] = r.split(",").map(x => x.trim());
    const p = playerData.find(x => x.name === n);
    if(p) p.sessions.push({ module: m, date: d });
  });

  populateDates();
  populatePlayers();
  renderModules();
  renderCharts();
  populateMonths();
  renderMonthlyAvgChart();
  await loadHawkinCSV();

  /* =========================
     Populate Module Dropdown
  ========================== */

  moduleBreakdownSelect.innerHTML =
    '<option value="">Select Module</option>';

  modules.forEach(m => {
    const o = document.createElement("option");
    o.value = m;
    o.textContent = m;
    moduleBreakdownSelect.appendChild(o);
  });

  // Auto-select first module
  if(modules.length){
    moduleBreakdownSelect.value = modules[0];
    renderModuleBreakdownChart();
  }
}

loadCSV();

function normalizeName(name){
  return name
    ?.replace(/"/g,"")
    .replace(/\s+/g,"")
    .toLowerCase()
    .trim();
}
async function loadHawkinCSV(){

  const res = await fetch("data/hawkin_cmj.csv?v=" + Date.now());
  const text = await res.text();

  Papa.parse(text,{
  header:true,
  skipEmptyLines:true,
  transformHeader: h =>
    h.replace(/^\uFEFF/, "").trim(),
  complete:(parsed)=>{

    const bestPerDay = {};

    parsed.data.forEach(row=>{

      const name =
        normalizeName(row["Name"]);
      if(!name) return;

      const date =
        row["Date"];
      if(!date) return;

      const jump =
        safeNum(row["Jump Height"]);
      if(jump === null) return;

      const key =
        name + "_" + date;

      if(
        !bestPerDay[key] ||
        jump > bestPerDay[key].jump
      ){
        bestPerDay[key] = {
          name,
          date,
          jump
        };
      }

    });

    Object.values(bestPerDay).forEach(entry=>{

      const p = playerData.find(
        x => normalizeName(x.name) === entry.name
      );

      if(p){
        p.hawkin.push({
          date: entry.date,
          jumpPct: entry.jump,
          asym: 0
        });
      }

    });

  }
});

/* ================= DROPDOWNS ================= */
let mostRecentDate = null;
function populateDates(){
  const dates = [...new Set(
    playerData.flatMap(p => p.sessions.map(s => s.date))
  )].sort((a,b) => new Date(b) - new Date(a));

  dateFilter.innerHTML = '<option value="">Select Date</option>';

  dates.forEach(d=>{
    const o = document.createElement("option");
    o.value = d;
    o.textContent = fmtDate(d);
    dateFilter.appendChild(o);
  });

  if(dates.length){
    mostRecentDate = dates[0]; // üî• save newest date
  }
}

function populatePlayers(){
  playerFilter.innerHTML='<option value="">Select Player</option>';
  if(!positionFilter.value)return;
  playerData.filter(p=>p.position===positionFilter.value)
    .sort((a,b)=>a.name.localeCompare(b.name))
    .forEach(p=>{
      const o=document.createElement("option");
      o.value=p.name;o.textContent=p.name;
      playerFilter.appendChild(o);
    });
}
function populateMonths(){
  const months = [
    ...new Set(playerData.flatMap(p =>
      p.sessions.map(s => monthKey(s.date))
    ))
  ].sort().reverse(); // most recent first

  monthFilter.innerHTML = "";
  months.forEach(m=>{
    const o=document.createElement("option");
    o.value=m;
    o.textContent=m;
    monthFilter.appendChild(o);
  });

  populateMonthWeeks();
}
function populateMonthWeeks(){
  monthWeekFilter.innerHTML = `<option value="all">All Weeks</option>`;

  const weeks = {};

  playerData.forEach(p=>{
    p.sessions.forEach(s=>{
      if(monthKey(s.date) !== monthFilter.value) return;
      const w = weekRange(s.date);
      weeks[w.label] = w; // dedupe by label
    });
  });

  Object.values(weeks)
    .sort((a,b)=>b.start - a.start) // most recent first
    .forEach(w=>{
      const o = document.createElement("option");
     o.value = w.label;
o.textContent = w.label;
      monthWeekFilter.appendChild(o);
    });
}


/* ================= PLAYER DETAILS ================= */
let playerModuleChart=null;
function getActiveWeekBaseDate(){

  const allDates = playerData.flatMap(p =>
    p.sessions.map(s => new Date(s.date))
  );

  if(!allDates.length){
    return new Date();
  }

  return new Date(
    Math.max(...allDates)
  );
}
function showPlayer(){
document.getElementById("playerDetailsEmpty")
  .classList.add("hidden");
  const p=playerData.find(x=>x.name===playerFilter.value);
  const today = getActiveWeekBaseDate();

const currentWeekStart = new Date(today);
currentWeekStart.setDate(today.getDate() - today.getDay());
currentWeekStart.setHours(0,0,0,0);

const currentWeekEnd = new Date(currentWeekStart);
currentWeekEnd.setDate(currentWeekStart.getDate() + 6);
currentWeekEnd.setHours(23,59,59,999);

const lastWeekStart = new Date(currentWeekStart);
lastWeekStart.setDate(currentWeekStart.getDate() - 7);

const lastWeekEnd = new Date(currentWeekEnd);
lastWeekEnd.setDate(currentWeekEnd.getDate() - 7);

const start =
  showingLastWeek
    ? lastWeekStart
    : currentWeekStart;

const end =
  showingLastWeek
    ? lastWeekEnd
    : currentWeekEnd;
  if(!p)return;
  // Show chart, hide empty state
document.querySelector("#playerModuleContainer .empty-state").style.display = "none";
document.getElementById("playerModuleChart").style.display = "block";

// Update title
document.getElementById("playerModuleTitle").textContent =
  `Cumulative Module Usage ‚Äì ${p.name}`;

  document.getElementById("playerDetailsTitle").textContent =
  `Player Details: ${p.name}`;
  playerStatsGrid.classList.remove("hidden");


  const lastDate = uniqueDates(p)
  .map(d => new Date(d))
  .sort((a, b) => b - a)[0];

playerLastDate.textContent = lastDate
  ? fmtDate(lastDate)
  : "N/A";
  document.getElementById("playerModuleTitle").textContent =
  `Cumulative Module Usage: ${p.name}`;
 
  const mods={};
  p.sessions.forEach(s=>mods[s.module]=(mods[s.module]||0)+1);
  playerMostModule.textContent=Object.keys(mods).sort((a,b)=>mods[b]-mods[a])[0]||"N/A";

  const group=playerData.filter(x=>x.position===p.position);
  const sortedGroup = group
  .map(player => ({
    name: player.name,
    days: uniqueDaysInRange(player,start,end)

  }))
  .sort((a,b)=>b.days - a.days);

let rank = 1;

for(let i = 0; i < sortedGroup.length; i++){

  if(i > 0 && sortedGroup[i].days < sortedGroup[i-1].days){
    rank = i + 1;
  }

  if(sortedGroup[i].name === p.name){
    break;
  }
}

const validDates = new Set();

playerData.forEach(x=>{
  x.sessions.forEach(s=>{
    const d = new Date(s.date);
    if(d >= start && d <= end){
      validDates.add(s.date);
    }
  });
});

const playerDays =
  uniqueDaysInRange(p,start,end);


const teamDays =
  validTeamInputDatesInRange(start,end);

// get all team-valid dates
const validTeamDates = new Set();

playerData.forEach(x=>{
  x.sessions.forEach(s=>{
    const d = new Date(s.date);
    if(
      d >= start &&
      d <= end &&
      validTeamInputDatesInRange(
        new Date(s.date),
        new Date(s.date)
      ) > 0
    ){
      validTeamDates.add(s.date);
    }
  });
});

// get player's low-participation bonus dates
const playerBonusDates = new Set(
  p.sessions
    .filter(s=>{
      const d = new Date(s.date);
      return (
        d >= start &&
        d <= end &&
        !validTeamDates.has(s.date)
      );
    })
    .map(s=>s.date)
);

// final denominator
const adjustedTeamDays =
  teamDays + playerBonusDates.size;

const pct =
  adjustedTeamDays === 0
    ? 0
    : Math.round((playerDays / adjustedTeamDays) * 100);

playerRecoveryDays.textContent =
  adjustedTeamDays === 0
    ? "-"
    : `${playerDays}/${adjustedTeamDays} (${pct}%)`;

const tieGroup =
  sortedGroup.filter(x =>
    x.days === playerDays
  );

const lowestDays =
  Math.min(...sortedGroup.map(x => x.days));

const positionSize =
  sortedGroup.length;

const isWorstTie =
  playerDays === lowestDays &&
  tieGroup.length > 1;

const rankText = isWorstTie
  ? `T-${positionSize}`
  : (tieGroup.length > 1
      ? `T-${rank}`
      : `${rank}`);


playerRank.textContent =
  `${rankText} out of ${group.length}`;



  renderPlayerModuleChart(p);
  recoveryDaysLabel.textContent =
  showingLastWeek
    ? "Recovery Days (Last Week)"
    : "Recovery Days (This Week)";

  const rankLabel =
  document.getElementById("rankLabel");

rankLabel.textContent =
  showingLastWeek
    ? "Rank in Position (Last Week)"
    : "Rank in Position (This Week)";

weekToggleLink.textContent =
  showingLastWeek
    ? "show current week"
    : "show last week";

  renderPlayerPerformanceChart(p);

console.log(p.name,p.hawkin.length);

}

/* ================= MODULE PARTICIPATION ================= */
function renderModules(){
  moduleGrid.innerHTML="";

  const pos = positionFilter.value;
  const date = dateFilter.value;

  if(!pos){
    document.getElementById("positionModuleTitle").textContent =
      "Module Participation";
    moduleGrid.innerHTML =
      `<div class="empty-state">Select a position to view module participation</div>`;
    return;
  }

  let activeDate = date;
  if(!activeDate && mostRecentDate){
    activeDate = mostRecentDate;
  }

  document.getElementById("positionModuleTitle").textContent =
    `${pos} Module Participation: ${fmtDate(activeDate)}`;

  modules.forEach(mod=>{
    const card = document.createElement("div");
    card.className = "module-card";
    card.innerHTML = `<h3>${mod}</h3><ul></ul>`;
    const ul = card.querySelector("ul");

    playerData
      .filter(p => p.position === pos)
      .forEach(p=>{
        const count = p.sessions.filter(
          s => s.module === mod && s.date === activeDate
        ).length;

        if(count > 0){
          const li = document.createElement("li");
          li.textContent = count > 1 ? `${p.name} x${count}` : p.name;
          ul.appendChild(li);
        }
      });

    moduleGrid.appendChild(card);
  });
}

/* ================= TEAM VIEW ================= */
function renderTeamView(){
  teamModuleGrid.innerHTML="";
  positions.forEach(pos=>{
    const sec=document.createElement("div");
    sec.className="team-position";
    sec.innerHTML=`<h2>${pos}</h2><div class="module-grid"></div>`;
    const grid=sec.querySelector(".module-grid");

    modules.forEach(mod=>{
      const card=document.createElement("div");
      card.className="module-card";
      card.innerHTML=`<h3>${mod}</h3><ul></ul>`;
      const ul=card.querySelector("ul");

      playerData.filter(p=>p.position===pos).forEach(p=>{
        const count=p.sessions.filter(s=>s.module===mod&&s.date===dateFilter.value).length;
        if(count>0){
          const li=document.createElement("li");
          li.textContent=count>1?`${p.name} x${count}`:p.name;
          ul.appendChild(li);
        }
      });

      grid.appendChild(card);
    });

    teamModuleGrid.appendChild(sec);
  });

  populateWeeks();
  renderLeaderboards();
}

function renderTeamRank(){

  teamRankSection.innerHTML = "";

  const card = document.createElement("div");
  card.className = "leaderboard";

  // üî• Make the inside split into two columns
  card.style.display = "grid";
  card.style.gridTemplateColumns = "1fr 1fr";
  card.style.gap = "40px";
  card.style.alignItems = "start";


  /* =========================
     LEFT COLUMN ‚Äî TEAM RANK
  ========================== */

  const rankDiv = document.createElement("div");
  rankDiv.style.borderRight =
  "1px solid rgba(253,249,216,.3)";
rankDiv.style.paddingRight = "20px";


  const today = new Date();

const currentWeekStart = new Date(today);
currentWeekStart.setDate(today.getDate() - today.getDay());
currentWeekStart.setHours(0,0,0,0);

const currentWeekEnd = new Date(currentWeekStart);
currentWeekEnd.setDate(currentWeekStart.getDate() + 6);
currentWeekEnd.setHours(23,59,59,999);

const rankedRoster = playerData
  .map(p => ({

    name: p.name,

    totalModules:
      showingWeeklyTeamRank
        ? totalModulesInRange(
            p,
            currentWeekStart,
            currentWeekEnd
          )
        : p.sessions.length

  }))
  .sort((a,b) => b.totalModules - a.totalModules);

  const displayRoster = showFullTeamRank
  ? rankedRoster
  : rankedRoster.slice(0, 25);


  let rankHTML = `
    <h3>
  Team Rank ‚Äì Total Modules
  <span
    id="teamRankWeekToggle"
    style="
      font-size:.7rem;
      margin-left:10px;
      cursor:pointer;
      text-decoration:underline;
      opacity:.75;
    ">
    ${showingWeeklyTeamRank ? "show all time" : "show this week"}
  </span>
</h3>
    <ol>
  `;

  displayRoster.forEach(p=>{
    rankHTML += `
      <li>
        ${p.name}
        <span style="opacity:.7;">
          (${p.totalModules})
        </span>
      </li>
    `;
  });

  rankHTML += "</ol>";
  if(rankedRoster.length > 25){

  rankHTML += `
    <div style="margin-top:15px; text-align:center;">
      <button id="teamRankExpandBtn">
        ${showFullTeamRank ? "Show Less" : "Show More"}
      </button>
    </div>
  `;
}


  rankDiv.innerHTML = rankHTML;
  const weekToggle =
  rankDiv.querySelector("#teamRankWeekToggle");

if(weekToggle){
  weekToggle.onclick = () => {
    showingWeeklyTeamRank =
      !showingWeeklyTeamRank;
    renderTeamRank();
  };
}
  const expandBtn =
  rankDiv.querySelector("#teamRankExpandBtn");

if(expandBtn){
  expandBtn.onclick = () => {
    showFullTeamRank = !showFullTeamRank;
    renderTeamRank();
  };
}



  /* =========================
     RIGHT COLUMN ‚Äî LEADERS & NOTES
  ========================== */

  const leadersDiv = document.createElement("div");
leadersDiv.style.paddingLeft = "20px";

  let leaderHTML = `
    <h3>Individual Leaders & Notes</h3>
    <table style="
  width:100%;
  border-collapse:collapse;
  font-size:1rem;
">
      <thead>
        <tr>
          <th style="text-align:left;">Position</th>
          <th style="text-align:left;">Days</th>
          <th style="text-align:left;">Notes</th>
        </tr>
      </thead>
      <tbody>
  `;

  positions.forEach(pos => {

    const group = playerData.filter(p => p.position === pos);
    if(!group.length) return;

    const leader = group
      .map(p => ({
        name: p.name,
        days: new Set(p.sessions.map(s=>s.date)).size
      }))
      .sort((a,b)=>b.days - a.days)[0];

    leaderHTML += `
      <tr>
        <td>
  ${pos}
  <div style="font-size:.85rem; opacity:.75;">
    ${leader.name}
  </div>
</td>
        <td>${leader.days}</td>
        <td style="opacity:.8;">
  ${positionNotes[pos] || ""}
</td>
      </tr>
    `;
  });

  leaderHTML += `
      </tbody>
    </table>
  `;

  leadersDiv.innerHTML = leaderHTML;

  card.appendChild(rankDiv);
  card.appendChild(leadersDiv);

  teamRankSection.appendChild(card);
}


/* ================= WEEKLY LEADERBOARD ================= */
function getWeekRange(dateStr){
  const d=new Date(dateStr);
  const start=new Date(d);start.setDate(d.getDate()-d.getDay());
  const end=new Date(start);end.setDate(start.getDate()+6);
  return{label:`${start.toLocaleDateString()} - ${end.toLocaleDateString()}`,start,end};
}
function populateWeeks(){
  weekFilter.innerHTML = "";
  const weeks = {};

  playerData.forEach(p=>{
    p.sessions.forEach(s=>{
      const w = getWeekRange(s.date);
      weeks[w.label] = w;
    });
  });

  const sortedWeeks = Object.values(weeks)
    .sort((a,b) => b.start - a.start);

  sortedWeeks.forEach(w=>{
    const o = document.createElement("option");
    o.value = w.label;
    o.textContent = w.label;
    weekFilter.appendChild(o);
  });

  if(sortedWeeks.length){
    weekFilter.value = sortedWeeks[0].label;
  }
}
function uniqueDaysInRange(player, start, end){

  return new Set(
    player.sessions
      .filter(s => {
        const d = new Date(s.date);
        return d >= start && d <= end;
      })
      .map(s => s.date)
  ).size;
}

function jumpPctInRange(player,start,end){

  const vals = player.hawkin
    .filter(h=>{
      const d=new Date(h.date);
      return d>=start && d<=end;
    })
    .map(h=>h.jumpPct)
    .filter(v=>!isNaN(v));

  if(!vals.length) return null;

  return vals.reduce((a,b)=>a+b,0)/vals.length;
}

function asymInRange(player,start,end){

  const vals = player.hawkin
    .filter(h=>{
      const d=new Date(h.date);
      return d>=start && d<=end;
    })
    .map(h=>h.asym)
    .filter(v=>!isNaN(v));

  if(!vals.length) return null;

  return vals.reduce((a,b)=>a+b,0)/vals.length;
}

function buildPerformanceTimeline(p){

  const weeks = {};

  p.sessions.forEach(s=>{
    const w = weekRange(s.date);
    weeks[w.label]=w;
  });

  const labels=[];
  const recovery=[];
  const jump=[];
  const asym=[];

  Object.values(weeks)
    .sort((a,b)=>a.start - b.start)
    .forEach(w=>{

      const playerDays =
        uniqueDaysInRange(p,w.start,w.end);

      const teamDays =
        validTeamInputDatesInRange(w.start,w.end);

      const adjustedDays =
        Math.max(playerDays,teamDays);

      const recPct =
        adjustedDays===0?null:(playerDays/adjustedDays)*100;

      const j = jumpPctInRange(p,w.start,w.end);
      const a = asymInRange(p,w.start,w.end);

      if(recPct!==null && j!==null && a!==null){
        labels.push(w.label);
        recovery.push(recPct);
        jump.push(j);
        asym.push(a);
      }

    });

  return{labels,recovery,jump,asym};
}

function teamInputDatesInRange(start, end){

  const dates = new Set();

  playerData.forEach(p => {
    p.sessions.forEach(s => {
      const d = new Date(s.date);
      if(d >= start && d <= end){
        dates.add(s.date);
      }
    });
  });

  return dates.size;
}

function totalModulesInRange(player, start, end){
  return player.sessions.filter(s=>{
    const d = new Date(s.date);
    return d >= start && d <= end;
  }).length;
}


function getEarliestWeekStart(){
  const dates = playerData.flatMap(p =>
    p.sessions.map(s => new Date(s.date))
  );

  if(!dates.length) return null;

  const earliest = new Date(Math.min(...dates));
  earliest.setDate(earliest.getDate() - earliest.getDay()); // normalize to week start
  earliest.setHours(0,0,0,0);

  return earliest;
}

function weekIsMatureEnough(currentInputs, previousInputs){
  if (previousInputs === 0) return false;
  return (currentInputs / previousInputs) >= 0.713;
}

function renderLeaderboards(){
  leaderboardContainer.innerHTML = "";
  if (!weekFilter.value) return;

  const weeklyLeaderboard = [];

  const [s, e] = weekFilter.value.split(" - ");
  const start = new Date(s);
  const end = new Date(e);

  const earliestWeekStart = getEarliestWeekStart();

  /* =====================
     TEAM INPUT DATE COUNTS (ONCE)
  ====================== */

 const thisWeekInputs =
  validTeamInputDatesInRange(start, end);

  const lastWeekStart = new Date(start);
  lastWeekStart.setDate(lastWeekStart.getDate() - 7);

  const lastWeekEnd = new Date(end);
  lastWeekEnd.setDate(lastWeekEnd.getDate() - 7);

  const lastWeekInputs =
  validTeamInputDatesInRange(lastWeekStart, lastWeekEnd);

  // üîí Week maturity gate (71.3%)
  const weekIsReady =
    weekIsMatureEnough(thisWeekInputs, lastWeekInputs);

  /* =====================
     LEADERBOARD LOOP
  ====================== */

  positions.forEach(pos => {
    const group = playerData.filter(p => p.position === pos);

   const ranked = group.length
? group.map(p => {

  const thisWeekDays =
  uniqueDaysInRange(p, start, end);

const lastWeekDays =
  uniqueDaysInRange(p, lastWeekStart, lastWeekEnd);



    const weeklyModules =
      totalModulesInRange(p, start, end);

    let trend = "";

    if(
      earliestWeekStart &&
      start.getTime() !== earliestWeekStart.getTime() &&
      weekIsReady
    ){
      trend = trendIndicator(
        thisWeekDays,
        lastWeekDays,
        thisWeekInputs,
        lastWeekInputs
      );
    }

    return {
      name: p.name,
      days: thisWeekDays,
      modules: weeklyModules,
      trend
    };

})
  : [];


// üîí All tied this week?
const uniqueWeeklyValues =
  new Set(ranked.map(p => p.days));

const allWeeklyTied =
  uniqueWeeklyValues.size === 1;


    // store for charts if needed
    weeklyLeaderboard.push({
      position: pos,
      players: ranked
    });

    /* =====================
       LEADERBOARD RENDER
    ====================== */

 let top;

const eligibleWeekly =
  ranked.filter(p => p.days > 0);

const nobodyActive =
  eligibleWeekly.length === 0;
 const fullWeeklyValues =
  new Set(ranked.map(p => p.days));

const everyoneSameNonZero =
  fullWeeklyValues.size === 1 &&
  [...fullWeeklyValues][0] > 0;


top = [];

if(!nobodyActive){
 top = eligibleWeekly
  .sort((a,b)=>{

    if(b.days !== a.days){
      return b.days - a.days;
    }

    // üî• TIE BREAKER
    return b.modules - a.modules;

  })
  .slice(0,5);
}

    // FULL POSITION RANKING
const fullRanked = [...ranked]
  .sort((a,b)=>{

    if(b.days !== a.days){
      return b.days - a.days;
    }

    return b.modules - a.modules;

  });
let trueRank = 1;

fullRanked.forEach((p,i)=>{

  if(i>0 && p.days < fullRanked[i-1].days){
    trueRank = i+1;
  }

  p.trueRank = trueRank;
});

// Get ALL ranks represented in Top 5
const topRanks =
  new Set(
    top.map(p => {
      const match =
        fullRanked.find(x => x.name === p.name);
      return match.trueRank;
    })
  );

// Remove ANYONE whose rank exists in Top
const eligibleBottom =
  fullRanked.filter(p =>
    !topRanks.has(p.trueRank)
  );

// Now take last 5 ONLY from ranks not shown above
const bottom = eligibleBottom
  .slice(-5)
  .sort((a,b)=>a.trueRank - b.trueRank);


    const div = document.createElement("div");
    div.className = "leaderboard";

  let html = `<h3>${pos}</h3>
            <strong>Top Performers</strong>
            <ul style="list-style:none; padding-left:0;">`;

if(nobodyActive){

  html += `<li style="opacity:.7;">
             No player has logged recovery this week
           </li>`;

}
else if(everyoneSameNonZero){

  // üî• rank by WEEKLY MODULES instead
  const moduleRanked = group.map(p => ({
    name: p.name,
    modules: totalModulesInRange(p,start,end)
  }))
  .filter(p => p.modules > 0)
  .sort((a,b)=>b.modules - a.modules)
  .slice(0,5);

  let prevVal = null;
  let displayRank = 0;

  moduleRanked.forEach((p,index)=>{

    if(prevVal === null || p.modules < prevVal){
      displayRank = index+1;
    }

    const tieCount =
      moduleRanked.filter(x =>
        x.modules === p.modules
      ).length;

    const rankText = tieCount > 1
      ? `T-${displayRank}`
      : `${displayRank}`;

    prevVal = p.modules;

    html += `
      <li>
        ${rankText}. ${p.name}
      </li>
    `;
  });

}
else{

  let prevValue = null;
  let displayRank = 0;

  top.forEach((p,index)=>{

    if(prevValue === null || p.days < prevValue){
      displayRank = index+1;
    }

    const tieCount =
      top.filter(x =>
        x.days === p.days
      ).length;

    const rankText = tieCount > 1
      ? `T-${displayRank}`
      : `${displayRank}`;

    prevValue = p.days;

    html += `
      <li>
        ${rankText}. ${p.name}
        ${p.trend || ""}
      </li>
    `;
  });

}

if(group.length > 5 && !nobodyActive && !everyoneSameNonZero){

 html += `
  <div style="
    margin-top:14px;
    margin-bottom:6px;
    font-weight:bold;
  ">
    Bottom Performers
  </div>

  <ul style="
    list-style:none;
    padding-left:0;
    margin-top:4px;
    margin-bottom:14px;
  ">
`;

if(bottom.length === 0){

  html += `
    <li style="opacity:.7;">
      No bottom performers this week
    </li>
  `;

}
else{

  let prevValue = null;
  let displayRank = 0;

bottom.forEach(p => {

  const lowestDays =
    Math.min(...fullRanked.map(x => x.days));

  const tieGroup =
    fullRanked.filter(x =>
      x.days === p.days
    );

  const positionSize = fullRanked.length;

  const isWorstTie =
  lowestDays === 0 &&     // üëà ONLY force T-LAST if worst = ZERO
  p.days === lowestDays &&
  tieGroup.length > 1;


  const rankText = isWorstTie
    ? `T-${positionSize}`
    : (tieGroup.length > 1
        ? `T-${p.trueRank}`
        : `${p.trueRank}`);

  html += `
    <li>
      ${rankText}. ${p.name}
      ${p.trend || ""}
    </li>
  `;
});

}

html += `</ul>`;
}
div.innerHTML = html;
leaderboardContainer.appendChild(div);
});   // closes positions.forEach

}   // üî• ADD THIS LINE (closes renderLeaderboards)

/* ================= CHARTS ================= */
function waitForChartBox(callback){

  const box =
    document.querySelector("#monthlyAvgChart")
      .parentElement;

  const check = () => {

    if(box.offsetHeight > 0){
      callback();
    } else {
      requestAnimationFrame(check);
    }

  };

  check();
}
teamChart=null;
function renderCharts(){
  const posDay={};
  playerData.forEach(p=>{
    uniqueDates(p).forEach(d=>{
      posDay[p.position]??={};
      posDay[p.position][d]=(posDay[p.position][d]||0)+1;
    });
  });

  const labels=Object.keys(posDay);
  const values=labels.map(pos=>{
    const total=roster.filter(r=>r.position===pos).length;
    const days=Object.values(posDay[pos]).map(c=>(c/total)*100);
    return days.length?(days.reduce((a,b)=>a+b)/days.length).toFixed(1):0;
  });


  const totals={};
  modules.forEach(m=>totals[m]=0);
  playerData.forEach(p=>p.sessions.forEach(s=>totals[s.module]++));

  teamChart?.destroy();
  teamChart=new Chart(
    document.getElementById("moduleChart"),
    {
      type:"bar",
      data:{
        labels:Object.keys(totals),
        datasets:[{label:"Total Uses",data:Object.values(totals),backgroundColor:cream}]
      },
      options:{
        scales:{
          x:{ticks:{color:cream}},
          y:{ticks:{color:cream},beginAtZero:true}
        },
        plugins:{legend:{labels:{color:cream}}}
      }
    }
  );
}
function renderPlayerModuleChart(p){
  // üîé Check if player has any usage at all
if(p.sessions.length === 0){
  document.getElementById("playerModuleChart").style.display = "none";
  document.querySelector("#playerModuleContainer .empty-state").style.display = "block";
  document.querySelector("#playerModuleContainer .empty-state").textContent =
    "No module usage yet for this player";
  return;
}

  const totals = {};
  const latestDates = {};

  modules.forEach(m=>{
    totals[m] = 0;
    latestDates[m] = null;
  });

  // Count uses + track most recent date per module
  p.sessions.forEach(s=>{
    totals[s.module]++;
    if(
      !latestDates[s.module] ||
      new Date(s.date) > new Date(latestDates[s.module])
    ){
      latestDates[s.module] = s.date;
    }
  });

  playerModuleChart?.destroy();

  playerModuleChart = new Chart(
    document.getElementById("playerModuleChart"),
    {
      type: "bar",
      data: {
        labels: modules, // ‚úÖ module names ONLY
        datasets: [{
          data: modules.map(m => totals[m]),
          backgroundColor: cream
        }]
      },
      options: {
        scales: {
          x: {
            ticks: { color: cream }

          },
          y: {
            ticks: { color: cream },
            beginAtZero: true
          }
        },
        plugins: {
          legend: { display: false },
          tooltip: {
            callbacks: {
              label: (ctx) => {
                const mod = ctx.label;
                const date = latestDates[mod] || "N/A";
                return [
                  `Total Uses: ${ctx.parsed.y}`,
                  `Latest Date: ${date}`
                ];
              }
            }
          }
        }
      }
    }
  );
}
let playerPerformanceChart=null;

function renderPlayerPerformanceChart(p){

  const t = buildPerformanceTimeline(p);

  playerPerformanceChart?.destroy();

  playerPerformanceChart = new Chart(
    document.getElementById("playerPerformanceChart"),
    {
      type:"line",
      data:{
        labels:t.labels,
        datasets:[
          {
            label:"Recovery %",
            data:t.recovery,
            borderColor:"#FDF9D8",
            tension:0.3
          },
          {
            label:"Jump % PR",
            data:t.jump,
            borderColor:"#4CAF50",
            tension:0.3
          },
          {
            label:"Asymmetry %",
            data:t.asym,
            borderColor:"#E53935",
            tension:0.3
          }
        ]
      },
      options:{
        plugins:{
          legend:{
            labels:{color:"#FDF9D8"}
          }
        },
        scales:{
          y:{
            min:0,
            max:100,
            ticks:{color:"#FDF9D8"}
          },
          x:{
            ticks:{color:"#FDF9D8"}
          }
        }
      }
    }
  );

}

let monthlyAvgChart = null;
function parseWeekLabel(label){

  const parts = label.split("-").map(x=>x.trim());

  return {
    start: new Date(parts[2], parts[0]-1, parts[1]),
    end:   new Date(parts[5], parts[3]-1, parts[4])
  };

}

function renderMonthlyAvgChart(){

  const posDay = {};
  const teamDateCounts = {};
  const playerDates = {};

  /* =========================
     PASS 1 ‚Äî TEAM COUNTS
  ========================== */

  playerData.forEach(p=>{

    playerDates[p.name] = new Set();

    p.sessions.forEach(s=>{

      if(monthKey(s.date) !== monthFilter.value) return;

      if(monthWeekFilter.value !== "all"){
        const w = weekRange(s.date);
        if(w.label !== monthWeekFilter.value) return;
      }

      teamDateCounts[s.date] =
        (teamDateCounts[s.date] || 0) + 1;

      playerDates[p.name].add(s.date);

    });

  });

  /* =========================
     ONLY KEEP ‚â•10 PARTICIPANTS
  ========================== */

  const validTeamDates = new Set(
    Object.entries(teamDateCounts)
      .filter(([date,count]) => count >= 10)
      .map(([date]) => date)
  );

  /* =========================
     BUILD POSITION DAY COUNTS
  ========================== */

  playerData.forEach(p=>{

    playerDates[p.name].forEach(d=>{

      if(!validTeamDates.has(d)) return;

      posDay[p.position] ??= {};
      posDay[p.position][d] =
        (posDay[p.position][d] || 0) + 1;

    });

  });

  /* =========================
     CALCULATE %
  ========================== */

  const labels = positions;

  const values = positions.map(pos=>{

    const rosterSize =
      roster.filter(r=>r.position===pos).length;

    if(rosterSize === 0) return 0;

    const inputDays =
      validTeamDates.size;

    if(inputDays === 0) return 0;

    const totalUses =
      Object.values(posDay[pos] || {})
        .reduce((a,b)=>a+b,0);

    return Number(
      ((totalUses / (rosterSize * inputDays)) * 100)
        .toFixed(1)
    );

  });

  monthlyAvgChart?.destroy();

  waitForChartBox(()=>{

    const canvas =
      document.getElementById("monthlyAvgChart");

    canvas.style.height = "380px";
    canvas.height = 380;

    monthlyAvgChart = new Chart(
      canvas,
      {
        type:"bar",
        data:{
          labels,
          datasets:[{
            data:values,
            backgroundColor:cream
          }]
        },
        options:{
          responsive:true,
          maintainAspectRatio:false,
          animation:false,
          scales:{
            x:{ticks:{color:cream}},
            y:{
              min:0,
              max:100,
              ticks:{
                color:cream,
                callback:v=>v+"%"
              }
            }
          },
          plugins:{
            legend:{display:false},
            tooltip:{
              callbacks:{
                label:ctx=>ctx.parsed.y+"%"
              }
            }
          }
        }
      }
    );

    requestAnimationFrame(()=>{
      requestAnimationFrame(()=>{
        monthlyAvgChart.resize();
      });
    });

  });

}
let moduleBreakdownChart = null;

function renderModuleBreakdownChart(){

  const selectedModule = moduleBreakdownSelect.value;
  if(!selectedModule) return;

  const positionCounts = {};
  let totalUses = 0;

  positions.forEach(pos => {
    positionCounts[pos] = 0;
  });

  playerData.forEach(p => {
    p.sessions.forEach(s => {
      if(s.module === selectedModule){
        positionCounts[p.position]++;
        totalUses++;
      }
    });
  });

  if(totalUses === 0) return;

  const labels = [];
  const values = [];

  Object.entries(positionCounts).forEach(([pos, count]) => {
    if(count > 0){
      labels.push(pos);
      values.push(
        ((count / totalUses) * 100).toFixed(1)
      );
    }
  });

  moduleBreakdownChart?.destroy();

  moduleBreakdownChart = new Chart(
    document.getElementById("moduleBreakdownChart"),
    {
      type: "doughnut",   // ‚Üê looks better than pie
      data: {
        labels,
        datasets: [{
  data: values,
  backgroundColor: labels.map(pos => positionColors[pos]),
  borderColor: "rgba(0,0,0,0.2)",
borderWidth: 1
}]
      },
      options: {
        cutout: "60%",
        plugins: {
          legend: {
            labels: { color: cream }
          },
          tooltip: {
            callbacks: {
              label: (ctx) =>
                `${ctx.label}: ${ctx.parsed}%`
            }
          }
        }
      }
    }
  );
}

/* ================= EVENTS ================= */
positionFilter.onchange = () => {
  populatePlayers();

  // üî• Auto-select most recent date if none selected
  if(!dateFilter.value && mostRecentDate){
    dateFilter.value = mostRecentDate;
  }

  renderModules();
};

playerFilter.onchange = () => {

  // üîÑ Player cleared
  if(!playerFilter.value){
  document.getElementById("playerDetailsEmpty")
  .classList.remove("hidden");
    // Reset titles
    document.getElementById("playerDetailsTitle").textContent = "Player Details";
    document.getElementById("playerModuleTitle").textContent = "Cumulative Module Usage";

    // Hide player stats
    playerStatsGrid.classList.add("hidden");

    // Hide chart, show empty state
    document.getElementById("playerModuleChart").style.display = "none";
    document.querySelector("#playerModuleContainer .empty-state").style.display = "block";

    return;
  }

  // ‚úÖ Player selected
  showPlayer();

};

dateFilter.onchange = () => {
  // Update player-view module participation
  renderModules();

  // ‚úÖ ALSO update team-view module participation if Team View is active
  if (!teamView.classList.contains("hidden")) {
    renderTeamView();
  }
};
toggleView.onclick = () => {
  const toTeam = teamView.classList.contains("hidden");

  // Toggle views
  playerView.classList.toggle("hidden");
  teamView.classList.toggle("hidden");

  // Hide irrelevant dropdowns in Team View
  playerFilter.classList.toggle("hidden");
  positionFilter.classList.toggle("hidden");

 // Update button label
toggleView.textContent =
  toTeam ? "Back to Player View" : "Team View";


  // Render team modules immediately when entering Team View
  if (toTeam) {
    renderTeamView();
  }
};
weekFilter.onchange=renderLeaderboards;
monthFilter.onchange = () => {
  populateMonthWeeks();
  renderMonthlyAvgChart();
};
const teamRankToggleBtn =
  document.getElementById("teamRankToggleBtn");

const teamModuleSection =
  document.getElementById("teamModuleSection");

const teamRankSection =
  document.getElementById("teamRankSection");
const weeklyLeaderboardSection =
  document.getElementById("weeklyLeaderboardSection");


let showingTeamRank = false;
let showFullTeamRank = false;
let showingWeeklyTeamRank = false;

teamRankToggleBtn.onclick = () => {

  showingTeamRank = !showingTeamRank;

  if(showingTeamRank){

  teamModuleSection.classList.add("hidden");

  // üî• SHOW weekly leaderboard here
  weeklyLeaderboardSection.classList.remove("hidden");

  renderTeamRank();
  teamRankSection.classList.remove("hidden");

  teamRankToggleBtn.textContent =
    "Back to Team View";


  } else {

  teamRankSection.classList.add("hidden");

  // üî• HIDE weekly leaderboard again
  weeklyLeaderboardSection.classList.add("hidden");

  teamModuleSection.classList.remove("hidden");

  teamRankToggleBtn.textContent =
    "Team Rank";

  }

};   // ‚úÖ closes teamRankToggleBtn.onclick

moduleBreakdownSelect.onchange =
  renderModuleBreakdownChart;

monthWeekFilter.addEventListener("input", () => {
  renderMonthlyAvgChart();
});

monthWeekFilter.addEventListener("change", () => {
  renderMonthlyAvgChart();
});

  });  
</script>

</body>
</html>
